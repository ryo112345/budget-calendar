/**
 * Generated by orval v7.13.2 üç∫
 * Do not edit manually.
 * Budget Calendar Service
 * Budget Calendar API
 * OpenAPI spec version: 1.0
 */
import { useMutation, useQuery } from "@tanstack/react-query";
import type {
  DataTag,
  DefinedInitialDataOptions,
  DefinedUseQueryResult,
  MutationFunction,
  QueryClient,
  QueryFunction,
  QueryKey,
  UndefinedInitialDataOptions,
  UseMutationOptions,
  UseMutationResult,
  UseQueryOptions,
  UseQueryResult,
} from "@tanstack/react-query";

import type {
  CreateTransactionInput,
  CreateTransactionResponse,
  DeleteTransactionsId404,
  ErrorBody,
  FetchTransactionListResponse,
  FetchTransactionResponse,
  GetTransactionsId404,
  GetTransactionsParams,
  PatchTransactionsId404,
  UpdateTransactionInput,
  UpdateTransactionResponse,
} from ".././model";

import { customFetch } from "../../custom-fetch";

type SecondParameter<T extends (...args: never) => unknown> = Parameters<T>[1];

/**
 * „É¶„Éº„Ç∂„Éº„Å´Á¥ê„Å•„ÅèÂèñÂºï‰∏ÄË¶ß„ÇíÂèñÂæó„ÄÇ„ÇØ„Ç®„É™„Éë„É©„É°„Éº„Çø„Åß„Éï„Ç£„É´„Çø„É™„É≥„Ç∞ÂèØËÉΩ
 * @summary Get Transactions
 */
export type getTransactionsResponse200 = {
  data: FetchTransactionListResponse;
  status: 200;
};

export type getTransactionsResponse400 = {
  data: ErrorBody;
  status: 400;
};

export type getTransactionsResponse500 = {
  data: ErrorBody;
  status: 500;
};

export type getTransactionsResponseSuccess = getTransactionsResponse200 & {
  headers: Headers;
};
export type getTransactionsResponseError = (getTransactionsResponse400 | getTransactionsResponse500) & {
  headers: Headers;
};

export type getTransactionsResponse = getTransactionsResponseSuccess | getTransactionsResponseError;

export const getGetTransactionsUrl = (params?: GetTransactionsParams) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? "null" : value.toString());
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `/transactions?${stringifiedParams}` : `/transactions`;
};

export const getTransactions = async (params?: GetTransactionsParams, options?: RequestInit): Promise<getTransactionsResponse> => {
  return customFetch<getTransactionsResponse>(getGetTransactionsUrl(params), {
    ...options,
    method: "GET",
  });
};

export const getGetTransactionsQueryKey = (params?: GetTransactionsParams) => {
  return [`/transactions`, ...(params ? [params] : [])] as const;
};

export const getGetTransactionsQueryOptions = <TData = Awaited<ReturnType<typeof getTransactions>>, TError = ErrorBody | ErrorBody>(
  params?: GetTransactionsParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getTransactions>>, TError, TData>>;
    request?: SecondParameter<typeof customFetch>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetTransactionsQueryKey(params);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getTransactions>>> = ({ signal }) => getTransactions(params, { signal, ...requestOptions });

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<Awaited<ReturnType<typeof getTransactions>>, TError, TData> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };
};

export type GetTransactionsQueryResult = NonNullable<Awaited<ReturnType<typeof getTransactions>>>;
export type GetTransactionsQueryError = ErrorBody | ErrorBody;

export function useGetTransactions<TData = Awaited<ReturnType<typeof getTransactions>>, TError = ErrorBody | ErrorBody>(
  params: undefined | GetTransactionsParams,
  options: {
    query: Partial<UseQueryOptions<Awaited<ReturnType<typeof getTransactions>>, TError, TData>> &
      Pick<
        DefinedInitialDataOptions<Awaited<ReturnType<typeof getTransactions>>, TError, Awaited<ReturnType<typeof getTransactions>>>,
        "initialData"
      >;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetTransactions<TData = Awaited<ReturnType<typeof getTransactions>>, TError = ErrorBody | ErrorBody>(
  params?: GetTransactionsParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getTransactions>>, TError, TData>> &
      Pick<
        UndefinedInitialDataOptions<Awaited<ReturnType<typeof getTransactions>>, TError, Awaited<ReturnType<typeof getTransactions>>>,
        "initialData"
      >;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetTransactions<TData = Awaited<ReturnType<typeof getTransactions>>, TError = ErrorBody | ErrorBody>(
  params?: GetTransactionsParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getTransactions>>, TError, TData>>;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
/**
 * @summary Get Transactions
 */

export function useGetTransactions<TData = Awaited<ReturnType<typeof getTransactions>>, TError = ErrorBody | ErrorBody>(
  params?: GetTransactionsParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getTransactions>>, TError, TData>>;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getGetTransactionsQueryOptions(params, options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Êñ∞„Åó„ÅÑÂèñÂºï„Çí‰ΩúÊàê
 * @summary Create Transaction
 */
export type postTransactionsResponse201 = {
  data: CreateTransactionResponse;
  status: 201;
};

export type postTransactionsResponse400 = {
  data: ErrorBody;
  status: 400;
};

export type postTransactionsResponse500 = {
  data: ErrorBody;
  status: 500;
};

export type postTransactionsResponseSuccess = postTransactionsResponse201 & {
  headers: Headers;
};
export type postTransactionsResponseError = (postTransactionsResponse400 | postTransactionsResponse500) & {
  headers: Headers;
};

export type postTransactionsResponse = postTransactionsResponseSuccess | postTransactionsResponseError;

export const getPostTransactionsUrl = () => {
  return `/transactions`;
};

export const postTransactions = async (createTransactionInput: CreateTransactionInput, options?: RequestInit): Promise<postTransactionsResponse> => {
  return customFetch<postTransactionsResponse>(getPostTransactionsUrl(), {
    ...options,
    method: "POST",
    headers: { "Content-Type": "application/json", ...options?.headers },
    body: JSON.stringify(createTransactionInput),
  });
};

export const getPostTransactionsMutationOptions = <TError = ErrorBody | ErrorBody, TContext = unknown>(options?: {
  mutation?: UseMutationOptions<Awaited<ReturnType<typeof postTransactions>>, TError, { data: CreateTransactionInput }, TContext>;
  request?: SecondParameter<typeof customFetch>;
}): UseMutationOptions<Awaited<ReturnType<typeof postTransactions>>, TError, { data: CreateTransactionInput }, TContext> => {
  const mutationKey = ["postTransactions"];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && "mutationKey" in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<Awaited<ReturnType<typeof postTransactions>>, { data: CreateTransactionInput }> = (props) => {
    const { data } = props ?? {};

    return postTransactions(data, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type PostTransactionsMutationResult = NonNullable<Awaited<ReturnType<typeof postTransactions>>>;
export type PostTransactionsMutationBody = CreateTransactionInput;
export type PostTransactionsMutationError = ErrorBody | ErrorBody;

/**
 * @summary Create Transaction
 */
export const usePostTransactions = <TError = ErrorBody | ErrorBody, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<Awaited<ReturnType<typeof postTransactions>>, TError, { data: CreateTransactionInput }, TContext>;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient,
): UseMutationResult<Awaited<ReturnType<typeof postTransactions>>, TError, { data: CreateTransactionInput }, TContext> => {
  const mutationOptions = getPostTransactionsMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};
/**
 * ÂèñÂºï„ÅÆË©≥Á¥∞„ÇíÂèñÂæó
 * @summary Get Transaction
 */
export type getTransactionsIdResponse200 = {
  data: FetchTransactionResponse;
  status: 200;
};

export type getTransactionsIdResponse400 = {
  data: ErrorBody;
  status: 400;
};

export type getTransactionsIdResponse404 = {
  data: GetTransactionsId404;
  status: 404;
};

export type getTransactionsIdResponse500 = {
  data: ErrorBody;
  status: 500;
};

export type getTransactionsIdResponseSuccess = getTransactionsIdResponse200 & {
  headers: Headers;
};
export type getTransactionsIdResponseError = (getTransactionsIdResponse400 | getTransactionsIdResponse404 | getTransactionsIdResponse500) & {
  headers: Headers;
};

export type getTransactionsIdResponse = getTransactionsIdResponseSuccess | getTransactionsIdResponseError;

export const getGetTransactionsIdUrl = (id: number) => {
  return `/transactions/${id}`;
};

export const getTransactionsId = async (id: number, options?: RequestInit): Promise<getTransactionsIdResponse> => {
  return customFetch<getTransactionsIdResponse>(getGetTransactionsIdUrl(id), {
    ...options,
    method: "GET",
  });
};

export const getGetTransactionsIdQueryKey = (id?: number) => {
  return [`/transactions/${id}`] as const;
};

export const getGetTransactionsIdQueryOptions = <
  TData = Awaited<ReturnType<typeof getTransactionsId>>,
  TError = ErrorBody | GetTransactionsId404 | ErrorBody,
>(
  id: number,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getTransactionsId>>, TError, TData>>;
    request?: SecondParameter<typeof customFetch>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetTransactionsIdQueryKey(id);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getTransactionsId>>> = ({ signal }) => getTransactionsId(id, { signal, ...requestOptions });

  return { queryKey, queryFn, enabled: !!id, ...queryOptions } as UseQueryOptions<Awaited<ReturnType<typeof getTransactionsId>>, TError, TData> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };
};

export type GetTransactionsIdQueryResult = NonNullable<Awaited<ReturnType<typeof getTransactionsId>>>;
export type GetTransactionsIdQueryError = ErrorBody | GetTransactionsId404 | ErrorBody;

export function useGetTransactionsId<TData = Awaited<ReturnType<typeof getTransactionsId>>, TError = ErrorBody | GetTransactionsId404 | ErrorBody>(
  id: number,
  options: {
    query: Partial<UseQueryOptions<Awaited<ReturnType<typeof getTransactionsId>>, TError, TData>> &
      Pick<
        DefinedInitialDataOptions<Awaited<ReturnType<typeof getTransactionsId>>, TError, Awaited<ReturnType<typeof getTransactionsId>>>,
        "initialData"
      >;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetTransactionsId<TData = Awaited<ReturnType<typeof getTransactionsId>>, TError = ErrorBody | GetTransactionsId404 | ErrorBody>(
  id: number,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getTransactionsId>>, TError, TData>> &
      Pick<
        UndefinedInitialDataOptions<Awaited<ReturnType<typeof getTransactionsId>>, TError, Awaited<ReturnType<typeof getTransactionsId>>>,
        "initialData"
      >;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetTransactionsId<TData = Awaited<ReturnType<typeof getTransactionsId>>, TError = ErrorBody | GetTransactionsId404 | ErrorBody>(
  id: number,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getTransactionsId>>, TError, TData>>;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
/**
 * @summary Get Transaction
 */

export function useGetTransactionsId<TData = Awaited<ReturnType<typeof getTransactionsId>>, TError = ErrorBody | GetTransactionsId404 | ErrorBody>(
  id: number,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getTransactionsId>>, TError, TData>>;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getGetTransactionsIdQueryOptions(id, options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * ÂèñÂºï„ÇíÊõ¥Êñ∞ÔºàÈÉ®ÂàÜÊõ¥Êñ∞Ôºâ
 * @summary Update Transaction
 */
export type patchTransactionsIdResponse200 = {
  data: UpdateTransactionResponse;
  status: 200;
};

export type patchTransactionsIdResponse400 = {
  data: ErrorBody;
  status: 400;
};

export type patchTransactionsIdResponse404 = {
  data: PatchTransactionsId404;
  status: 404;
};

export type patchTransactionsIdResponse500 = {
  data: ErrorBody;
  status: 500;
};

export type patchTransactionsIdResponseSuccess = patchTransactionsIdResponse200 & {
  headers: Headers;
};
export type patchTransactionsIdResponseError = (patchTransactionsIdResponse400 | patchTransactionsIdResponse404 | patchTransactionsIdResponse500) & {
  headers: Headers;
};

export type patchTransactionsIdResponse = patchTransactionsIdResponseSuccess | patchTransactionsIdResponseError;

export const getPatchTransactionsIdUrl = (id: number) => {
  return `/transactions/${id}`;
};

export const patchTransactionsId = async (
  id: number,
  updateTransactionInput: UpdateTransactionInput,
  options?: RequestInit,
): Promise<patchTransactionsIdResponse> => {
  return customFetch<patchTransactionsIdResponse>(getPatchTransactionsIdUrl(id), {
    ...options,
    method: "PATCH",
    headers: { "Content-Type": "application/json", ...options?.headers },
    body: JSON.stringify(updateTransactionInput),
  });
};

export const getPatchTransactionsIdMutationOptions = <TError = ErrorBody | PatchTransactionsId404 | ErrorBody, TContext = unknown>(options?: {
  mutation?: UseMutationOptions<Awaited<ReturnType<typeof patchTransactionsId>>, TError, { id: number; data: UpdateTransactionInput }, TContext>;
  request?: SecondParameter<typeof customFetch>;
}): UseMutationOptions<Awaited<ReturnType<typeof patchTransactionsId>>, TError, { id: number; data: UpdateTransactionInput }, TContext> => {
  const mutationKey = ["patchTransactionsId"];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && "mutationKey" in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<Awaited<ReturnType<typeof patchTransactionsId>>, { id: number; data: UpdateTransactionInput }> = (props) => {
    const { id, data } = props ?? {};

    return patchTransactionsId(id, data, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type PatchTransactionsIdMutationResult = NonNullable<Awaited<ReturnType<typeof patchTransactionsId>>>;
export type PatchTransactionsIdMutationBody = UpdateTransactionInput;
export type PatchTransactionsIdMutationError = ErrorBody | PatchTransactionsId404 | ErrorBody;

/**
 * @summary Update Transaction
 */
export const usePatchTransactionsId = <TError = ErrorBody | PatchTransactionsId404 | ErrorBody, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<Awaited<ReturnType<typeof patchTransactionsId>>, TError, { id: number; data: UpdateTransactionInput }, TContext>;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient,
): UseMutationResult<Awaited<ReturnType<typeof patchTransactionsId>>, TError, { id: number; data: UpdateTransactionInput }, TContext> => {
  const mutationOptions = getPatchTransactionsIdMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};
/**
 * ÂèñÂºï„ÇíÂâäÈô§
 * @summary Delete Transaction
 */
export type deleteTransactionsIdResponse204 = {
  data: void;
  status: 204;
};

export type deleteTransactionsIdResponse404 = {
  data: DeleteTransactionsId404;
  status: 404;
};

export type deleteTransactionsIdResponse500 = {
  data: ErrorBody;
  status: 500;
};

export type deleteTransactionsIdResponseSuccess = deleteTransactionsIdResponse204 & {
  headers: Headers;
};
export type deleteTransactionsIdResponseError = (deleteTransactionsIdResponse404 | deleteTransactionsIdResponse500) & {
  headers: Headers;
};

export type deleteTransactionsIdResponse = deleteTransactionsIdResponseSuccess | deleteTransactionsIdResponseError;

export const getDeleteTransactionsIdUrl = (id: number) => {
  return `/transactions/${id}`;
};

export const deleteTransactionsId = async (id: number, options?: RequestInit): Promise<deleteTransactionsIdResponse> => {
  return customFetch<deleteTransactionsIdResponse>(getDeleteTransactionsIdUrl(id), {
    ...options,
    method: "DELETE",
  });
};

export const getDeleteTransactionsIdMutationOptions = <TError = DeleteTransactionsId404 | ErrorBody, TContext = unknown>(options?: {
  mutation?: UseMutationOptions<Awaited<ReturnType<typeof deleteTransactionsId>>, TError, { id: number }, TContext>;
  request?: SecondParameter<typeof customFetch>;
}): UseMutationOptions<Awaited<ReturnType<typeof deleteTransactionsId>>, TError, { id: number }, TContext> => {
  const mutationKey = ["deleteTransactionsId"];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && "mutationKey" in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<Awaited<ReturnType<typeof deleteTransactionsId>>, { id: number }> = (props) => {
    const { id } = props ?? {};

    return deleteTransactionsId(id, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type DeleteTransactionsIdMutationResult = NonNullable<Awaited<ReturnType<typeof deleteTransactionsId>>>;

export type DeleteTransactionsIdMutationError = DeleteTransactionsId404 | ErrorBody;

/**
 * @summary Delete Transaction
 */
export const useDeleteTransactionsId = <TError = DeleteTransactionsId404 | ErrorBody, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<Awaited<ReturnType<typeof deleteTransactionsId>>, TError, { id: number }, TContext>;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient,
): UseMutationResult<Awaited<ReturnType<typeof deleteTransactionsId>>, TError, { id: number }, TContext> => {
  const mutationOptions = getDeleteTransactionsIdMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};
