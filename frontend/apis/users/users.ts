/**
 * Generated by orval v7.13.2 üç∫
 * Do not edit manually.
 * Budget Calendar Service
 * Budget Calendar API
 * OpenAPI spec version: 1.0
 */
import { useMutation, useQuery } from "@tanstack/react-query";
import type {
  DataTag,
  DefinedInitialDataOptions,
  DefinedUseQueryResult,
  MutationFunction,
  QueryClient,
  QueryFunction,
  QueryKey,
  UndefinedInitialDataOptions,
  UseMutationOptions,
  UseMutationResult,
  UseQueryOptions,
  UseQueryResult,
} from "@tanstack/react-query";

import type {
  ErrorBody,
  UserSignInInput,
  UserSignUpInput,
  UserUserCheckSignedInResponse,
  UserUserSignInResponse,
  UserUserSignOutResponse,
  UserUserSignUpResponse,
} from ".././model";

import { customFetch } from "../../shared/lib/fetch";

type SecondParameter<T extends (...args: never) => unknown> = Parameters<T>[1];

/**
 * „É≠„Ç∞„Ç§„É≥Áä∂ÊÖãÁ¢∫Ë™ç
 * @summary User CheckSignedIn
 */
export const getGetUsersCheckSignedInUrl = () => {
  return `/users/checkSignedIn`;
};

export const getUsersCheckSignedIn = async (options?: RequestInit): Promise<UserUserCheckSignedInResponse> => {
  return customFetch<UserUserCheckSignedInResponse>(getGetUsersCheckSignedInUrl(), {
    ...options,
    method: "GET",
  });
};

export const getGetUsersCheckSignedInQueryKey = () => {
  return [`/users/checkSignedIn`] as const;
};

export const getGetUsersCheckSignedInQueryOptions = <TData = Awaited<ReturnType<typeof getUsersCheckSignedIn>>, TError = unknown>(options?: {
  query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getUsersCheckSignedIn>>, TError, TData>>;
  request?: SecondParameter<typeof customFetch>;
}) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetUsersCheckSignedInQueryKey();

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getUsersCheckSignedIn>>> = ({ signal }) =>
    getUsersCheckSignedIn({ signal, ...requestOptions });

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<Awaited<ReturnType<typeof getUsersCheckSignedIn>>, TError, TData> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };
};

export type GetUsersCheckSignedInQueryResult = NonNullable<Awaited<ReturnType<typeof getUsersCheckSignedIn>>>;
export type GetUsersCheckSignedInQueryError = unknown;

export function useGetUsersCheckSignedIn<TData = Awaited<ReturnType<typeof getUsersCheckSignedIn>>, TError = unknown>(
  options: {
    query: Partial<UseQueryOptions<Awaited<ReturnType<typeof getUsersCheckSignedIn>>, TError, TData>> &
      Pick<
        DefinedInitialDataOptions<Awaited<ReturnType<typeof getUsersCheckSignedIn>>, TError, Awaited<ReturnType<typeof getUsersCheckSignedIn>>>,
        "initialData"
      >;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetUsersCheckSignedIn<TData = Awaited<ReturnType<typeof getUsersCheckSignedIn>>, TError = unknown>(
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getUsersCheckSignedIn>>, TError, TData>> &
      Pick<
        UndefinedInitialDataOptions<Awaited<ReturnType<typeof getUsersCheckSignedIn>>, TError, Awaited<ReturnType<typeof getUsersCheckSignedIn>>>,
        "initialData"
      >;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetUsersCheckSignedIn<TData = Awaited<ReturnType<typeof getUsersCheckSignedIn>>, TError = unknown>(
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getUsersCheckSignedIn>>, TError, TData>>;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
/**
 * @summary User CheckSignedIn
 */

export function useGetUsersCheckSignedIn<TData = Awaited<ReturnType<typeof getUsersCheckSignedIn>>, TError = unknown>(
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getUsersCheckSignedIn>>, TError, TData>>;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getGetUsersCheckSignedInQueryOptions(options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * „É¶„Éº„Ç∂„Éº„É≠„Ç∞„Ç§„É≥
 * @summary User SignIn
 */
export const getPostUsersSignInUrl = () => {
  return `/users/signIn`;
};

export const postUsersSignIn = async (userSignInInput: UserSignInInput, options?: RequestInit): Promise<UserUserSignInResponse> => {
  return customFetch<UserUserSignInResponse>(getPostUsersSignInUrl(), {
    ...options,
    method: "POST",
    headers: { "Content-Type": "application/json", ...options?.headers },
    body: JSON.stringify(userSignInInput),
  });
};

export const getPostUsersSignInMutationOptions = <TError = ErrorBody | ErrorBody | ErrorBody, TContext = unknown>(options?: {
  mutation?: UseMutationOptions<Awaited<ReturnType<typeof postUsersSignIn>>, TError, { data: UserSignInInput }, TContext>;
  request?: SecondParameter<typeof customFetch>;
}): UseMutationOptions<Awaited<ReturnType<typeof postUsersSignIn>>, TError, { data: UserSignInInput }, TContext> => {
  const mutationKey = ["postUsersSignIn"];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && "mutationKey" in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<Awaited<ReturnType<typeof postUsersSignIn>>, { data: UserSignInInput }> = (props) => {
    const { data } = props ?? {};

    return postUsersSignIn(data, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type PostUsersSignInMutationResult = NonNullable<Awaited<ReturnType<typeof postUsersSignIn>>>;
export type PostUsersSignInMutationBody = UserSignInInput;
export type PostUsersSignInMutationError = ErrorBody | ErrorBody | ErrorBody;

/**
 * @summary User SignIn
 */
export const usePostUsersSignIn = <TError = ErrorBody | ErrorBody | ErrorBody, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<Awaited<ReturnType<typeof postUsersSignIn>>, TError, { data: UserSignInInput }, TContext>;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient,
): UseMutationResult<Awaited<ReturnType<typeof postUsersSignIn>>, TError, { data: UserSignInInput }, TContext> => {
  const mutationOptions = getPostUsersSignInMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};
/**
 * „É¶„Éº„Ç∂„Éº„É≠„Ç∞„Ç¢„Ç¶„Éà
 * @summary User SignOut
 */
export const getPostUsersSignOutUrl = () => {
  return `/users/signOut`;
};

export const postUsersSignOut = async (options?: RequestInit): Promise<UserUserSignOutResponse> => {
  return customFetch<UserUserSignOutResponse>(getPostUsersSignOutUrl(), {
    ...options,
    method: "POST",
  });
};

export const getPostUsersSignOutMutationOptions = <TError = ErrorBody, TContext = unknown>(options?: {
  mutation?: UseMutationOptions<Awaited<ReturnType<typeof postUsersSignOut>>, TError, void, TContext>;
  request?: SecondParameter<typeof customFetch>;
}): UseMutationOptions<Awaited<ReturnType<typeof postUsersSignOut>>, TError, void, TContext> => {
  const mutationKey = ["postUsersSignOut"];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && "mutationKey" in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<Awaited<ReturnType<typeof postUsersSignOut>>, void> = () => {
    return postUsersSignOut(requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type PostUsersSignOutMutationResult = NonNullable<Awaited<ReturnType<typeof postUsersSignOut>>>;

export type PostUsersSignOutMutationError = ErrorBody;

/**
 * @summary User SignOut
 */
export const usePostUsersSignOut = <TError = ErrorBody, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<Awaited<ReturnType<typeof postUsersSignOut>>, TError, void, TContext>;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient,
): UseMutationResult<Awaited<ReturnType<typeof postUsersSignOut>>, TError, void, TContext> => {
  const mutationOptions = getPostUsersSignOutMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};
/**
 * „É¶„Éº„Ç∂„ÉºÁôªÈå≤
 * @summary User SignUp
 */
export const getPostUsersSignUpUrl = () => {
  return `/users/signUp`;
};

export const postUsersSignUp = async (userSignUpInput: UserSignUpInput, options?: RequestInit): Promise<UserUserSignUpResponse> => {
  return customFetch<UserUserSignUpResponse>(getPostUsersSignUpUrl(), {
    ...options,
    method: "POST",
    headers: { "Content-Type": "application/json", ...options?.headers },
    body: JSON.stringify(userSignUpInput),
  });
};

export const getPostUsersSignUpMutationOptions = <TError = ErrorBody | ErrorBody | ErrorBody, TContext = unknown>(options?: {
  mutation?: UseMutationOptions<Awaited<ReturnType<typeof postUsersSignUp>>, TError, { data: UserSignUpInput }, TContext>;
  request?: SecondParameter<typeof customFetch>;
}): UseMutationOptions<Awaited<ReturnType<typeof postUsersSignUp>>, TError, { data: UserSignUpInput }, TContext> => {
  const mutationKey = ["postUsersSignUp"];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && "mutationKey" in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<Awaited<ReturnType<typeof postUsersSignUp>>, { data: UserSignUpInput }> = (props) => {
    const { data } = props ?? {};

    return postUsersSignUp(data, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type PostUsersSignUpMutationResult = NonNullable<Awaited<ReturnType<typeof postUsersSignUp>>>;
export type PostUsersSignUpMutationBody = UserSignUpInput;
export type PostUsersSignUpMutationError = ErrorBody | ErrorBody | ErrorBody;

/**
 * @summary User SignUp
 */
export const usePostUsersSignUp = <TError = ErrorBody | ErrorBody | ErrorBody, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<Awaited<ReturnType<typeof postUsersSignUp>>, TError, { data: UserSignUpInput }, TContext>;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient,
): UseMutationResult<Awaited<ReturnType<typeof postUsersSignUp>>, TError, { data: UserSignUpInput }, TContext> => {
  const mutationOptions = getPostUsersSignUpMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};
