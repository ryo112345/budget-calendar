/**
 * Generated by orval v7.13.2 üç∫
 * Do not edit manually.
 * Budget Calendar Service
 * Budget Calendar API
 * OpenAPI spec version: 1.0
 */
import { useMutation, useQuery } from "@tanstack/react-query";
import type {
  DataTag,
  DefinedInitialDataOptions,
  DefinedUseQueryResult,
  MutationFunction,
  QueryClient,
  QueryFunction,
  QueryKey,
  UndefinedInitialDataOptions,
  UseMutationOptions,
  UseMutationResult,
  UseQueryOptions,
  UseQueryResult,
} from "@tanstack/react-query";

import type {
  CreateBudgetInput,
  CreateBudgetResponse,
  ErrorBody,
  FetchBudgetListResponse,
  FetchBudgetResponse,
  GetBudgetsParams,
  UpdateBudgetInput,
  UpdateBudgetResponse,
} from ".././model";

import { customFetch } from "../../custom-fetch";

type SecondParameter<T extends (...args: never) => unknown> = Parameters<T>[1];

/**
 * „É¶„Éº„Ç∂„Éº„Å´Á¥ê„Å•„Åè‰∫àÁÆó‰∏ÄË¶ß„ÇíÂèñÂæó„ÄÇ„ÇØ„Ç®„É™„Éë„É©„É°„Éº„Çø„Åß„Éï„Ç£„É´„Çø„É™„É≥„Ç∞ÂèØËÉΩ
 * @summary Get Budgets
 */
export type getBudgetsResponse200 = {
  data: FetchBudgetListResponse;
  status: 200;
};

export type getBudgetsResponse400 = {
  data: ErrorBody;
  status: 400;
};

export type getBudgetsResponse500 = {
  data: ErrorBody;
  status: 500;
};

export type getBudgetsResponseSuccess = getBudgetsResponse200 & {
  headers: Headers;
};
export type getBudgetsResponseError = (getBudgetsResponse400 | getBudgetsResponse500) & {
  headers: Headers;
};

export type getBudgetsResponse = getBudgetsResponseSuccess | getBudgetsResponseError;

export const getGetBudgetsUrl = (params?: GetBudgetsParams) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? "null" : value.toString());
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `/budgets?${stringifiedParams}` : `/budgets`;
};

export const getBudgets = async (params?: GetBudgetsParams, options?: RequestInit): Promise<getBudgetsResponse> => {
  return customFetch<getBudgetsResponse>(getGetBudgetsUrl(params), {
    ...options,
    method: "GET",
  });
};

export const getGetBudgetsQueryKey = (params?: GetBudgetsParams) => {
  return [`/budgets`, ...(params ? [params] : [])] as const;
};

export const getGetBudgetsQueryOptions = <TData = Awaited<ReturnType<typeof getBudgets>>, TError = ErrorBody | ErrorBody>(
  params?: GetBudgetsParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getBudgets>>, TError, TData>>;
    request?: SecondParameter<typeof customFetch>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetBudgetsQueryKey(params);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getBudgets>>> = ({ signal }) => getBudgets(params, { signal, ...requestOptions });

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<Awaited<ReturnType<typeof getBudgets>>, TError, TData> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };
};

export type GetBudgetsQueryResult = NonNullable<Awaited<ReturnType<typeof getBudgets>>>;
export type GetBudgetsQueryError = ErrorBody | ErrorBody;

export function useGetBudgets<TData = Awaited<ReturnType<typeof getBudgets>>, TError = ErrorBody | ErrorBody>(
  params: undefined | GetBudgetsParams,
  options: {
    query: Partial<UseQueryOptions<Awaited<ReturnType<typeof getBudgets>>, TError, TData>> &
      Pick<DefinedInitialDataOptions<Awaited<ReturnType<typeof getBudgets>>, TError, Awaited<ReturnType<typeof getBudgets>>>, "initialData">;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetBudgets<TData = Awaited<ReturnType<typeof getBudgets>>, TError = ErrorBody | ErrorBody>(
  params?: GetBudgetsParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getBudgets>>, TError, TData>> &
      Pick<UndefinedInitialDataOptions<Awaited<ReturnType<typeof getBudgets>>, TError, Awaited<ReturnType<typeof getBudgets>>>, "initialData">;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetBudgets<TData = Awaited<ReturnType<typeof getBudgets>>, TError = ErrorBody | ErrorBody>(
  params?: GetBudgetsParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getBudgets>>, TError, TData>>;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
/**
 * @summary Get Budgets
 */

export function useGetBudgets<TData = Awaited<ReturnType<typeof getBudgets>>, TError = ErrorBody | ErrorBody>(
  params?: GetBudgetsParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getBudgets>>, TError, TData>>;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getGetBudgetsQueryOptions(params, options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Êñ∞„Åó„ÅÑ‰∫àÁÆó„Çí‰ΩúÊàê
 * @summary Create Budget
 */
export type postBudgetsResponse201 = {
  data: CreateBudgetResponse;
  status: 201;
};

export type postBudgetsResponse400 = {
  data: ErrorBody;
  status: 400;
};

export type postBudgetsResponse409 = {
  data: ErrorBody;
  status: 409;
};

export type postBudgetsResponse500 = {
  data: ErrorBody;
  status: 500;
};

export type postBudgetsResponseSuccess = postBudgetsResponse201 & {
  headers: Headers;
};
export type postBudgetsResponseError = (postBudgetsResponse400 | postBudgetsResponse409 | postBudgetsResponse500) & {
  headers: Headers;
};

export type postBudgetsResponse = postBudgetsResponseSuccess | postBudgetsResponseError;

export const getPostBudgetsUrl = () => {
  return `/budgets`;
};

export const postBudgets = async (createBudgetInput: CreateBudgetInput, options?: RequestInit): Promise<postBudgetsResponse> => {
  return customFetch<postBudgetsResponse>(getPostBudgetsUrl(), {
    ...options,
    method: "POST",
    headers: { "Content-Type": "application/json", ...options?.headers },
    body: JSON.stringify(createBudgetInput),
  });
};

export const getPostBudgetsMutationOptions = <TError = ErrorBody | ErrorBody | ErrorBody, TContext = unknown>(options?: {
  mutation?: UseMutationOptions<Awaited<ReturnType<typeof postBudgets>>, TError, { data: CreateBudgetInput }, TContext>;
  request?: SecondParameter<typeof customFetch>;
}): UseMutationOptions<Awaited<ReturnType<typeof postBudgets>>, TError, { data: CreateBudgetInput }, TContext> => {
  const mutationKey = ["postBudgets"];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && "mutationKey" in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<Awaited<ReturnType<typeof postBudgets>>, { data: CreateBudgetInput }> = (props) => {
    const { data } = props ?? {};

    return postBudgets(data, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type PostBudgetsMutationResult = NonNullable<Awaited<ReturnType<typeof postBudgets>>>;
export type PostBudgetsMutationBody = CreateBudgetInput;
export type PostBudgetsMutationError = ErrorBody | ErrorBody | ErrorBody;

/**
 * @summary Create Budget
 */
export const usePostBudgets = <TError = ErrorBody | ErrorBody | ErrorBody, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<Awaited<ReturnType<typeof postBudgets>>, TError, { data: CreateBudgetInput }, TContext>;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient,
): UseMutationResult<Awaited<ReturnType<typeof postBudgets>>, TError, { data: CreateBudgetInput }, TContext> => {
  const mutationOptions = getPostBudgetsMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};
/**
 * ‰∫àÁÆó„ÅÆË©≥Á¥∞„ÇíÂèñÂæó
 * @summary Get Budget
 */
export type getBudgetsIdResponse200 = {
  data: FetchBudgetResponse;
  status: 200;
};

export type getBudgetsIdResponse400 = {
  data: ErrorBody;
  status: 400;
};

export type getBudgetsIdResponse404 = {
  data: ErrorBody;
  status: 404;
};

export type getBudgetsIdResponse500 = {
  data: ErrorBody;
  status: 500;
};

export type getBudgetsIdResponseSuccess = getBudgetsIdResponse200 & {
  headers: Headers;
};
export type getBudgetsIdResponseError = (getBudgetsIdResponse400 | getBudgetsIdResponse404 | getBudgetsIdResponse500) & {
  headers: Headers;
};

export type getBudgetsIdResponse = getBudgetsIdResponseSuccess | getBudgetsIdResponseError;

export const getGetBudgetsIdUrl = (id: number) => {
  return `/budgets/${id}`;
};

export const getBudgetsId = async (id: number, options?: RequestInit): Promise<getBudgetsIdResponse> => {
  return customFetch<getBudgetsIdResponse>(getGetBudgetsIdUrl(id), {
    ...options,
    method: "GET",
  });
};

export const getGetBudgetsIdQueryKey = (id?: number) => {
  return [`/budgets/${id}`] as const;
};

export const getGetBudgetsIdQueryOptions = <TData = Awaited<ReturnType<typeof getBudgetsId>>, TError = ErrorBody | ErrorBody | ErrorBody>(
  id: number,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getBudgetsId>>, TError, TData>>;
    request?: SecondParameter<typeof customFetch>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetBudgetsIdQueryKey(id);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getBudgetsId>>> = ({ signal }) => getBudgetsId(id, { signal, ...requestOptions });

  return { queryKey, queryFn, enabled: !!id, ...queryOptions } as UseQueryOptions<Awaited<ReturnType<typeof getBudgetsId>>, TError, TData> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };
};

export type GetBudgetsIdQueryResult = NonNullable<Awaited<ReturnType<typeof getBudgetsId>>>;
export type GetBudgetsIdQueryError = ErrorBody | ErrorBody | ErrorBody;

export function useGetBudgetsId<TData = Awaited<ReturnType<typeof getBudgetsId>>, TError = ErrorBody | ErrorBody | ErrorBody>(
  id: number,
  options: {
    query: Partial<UseQueryOptions<Awaited<ReturnType<typeof getBudgetsId>>, TError, TData>> &
      Pick<DefinedInitialDataOptions<Awaited<ReturnType<typeof getBudgetsId>>, TError, Awaited<ReturnType<typeof getBudgetsId>>>, "initialData">;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetBudgetsId<TData = Awaited<ReturnType<typeof getBudgetsId>>, TError = ErrorBody | ErrorBody | ErrorBody>(
  id: number,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getBudgetsId>>, TError, TData>> &
      Pick<UndefinedInitialDataOptions<Awaited<ReturnType<typeof getBudgetsId>>, TError, Awaited<ReturnType<typeof getBudgetsId>>>, "initialData">;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetBudgetsId<TData = Awaited<ReturnType<typeof getBudgetsId>>, TError = ErrorBody | ErrorBody | ErrorBody>(
  id: number,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getBudgetsId>>, TError, TData>>;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
/**
 * @summary Get Budget
 */

export function useGetBudgetsId<TData = Awaited<ReturnType<typeof getBudgetsId>>, TError = ErrorBody | ErrorBody | ErrorBody>(
  id: number,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getBudgetsId>>, TError, TData>>;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getGetBudgetsIdQueryOptions(id, options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * ‰∫àÁÆó„ÇíÊõ¥Êñ∞ÔºàÈÉ®ÂàÜÊõ¥Êñ∞Ôºâ
 * @summary Update Budget
 */
export type patchBudgetsIdResponse200 = {
  data: UpdateBudgetResponse;
  status: 200;
};

export type patchBudgetsIdResponse400 = {
  data: ErrorBody;
  status: 400;
};

export type patchBudgetsIdResponse404 = {
  data: ErrorBody;
  status: 404;
};

export type patchBudgetsIdResponse409 = {
  data: ErrorBody;
  status: 409;
};

export type patchBudgetsIdResponse500 = {
  data: ErrorBody;
  status: 500;
};

export type patchBudgetsIdResponseSuccess = patchBudgetsIdResponse200 & {
  headers: Headers;
};
export type patchBudgetsIdResponseError = (
  | patchBudgetsIdResponse400
  | patchBudgetsIdResponse404
  | patchBudgetsIdResponse409
  | patchBudgetsIdResponse500
) & {
  headers: Headers;
};

export type patchBudgetsIdResponse = patchBudgetsIdResponseSuccess | patchBudgetsIdResponseError;

export const getPatchBudgetsIdUrl = (id: number) => {
  return `/budgets/${id}`;
};

export const patchBudgetsId = async (id: number, updateBudgetInput: UpdateBudgetInput, options?: RequestInit): Promise<patchBudgetsIdResponse> => {
  return customFetch<patchBudgetsIdResponse>(getPatchBudgetsIdUrl(id), {
    ...options,
    method: "PATCH",
    headers: { "Content-Type": "application/json", ...options?.headers },
    body: JSON.stringify(updateBudgetInput),
  });
};

export const getPatchBudgetsIdMutationOptions = <TError = ErrorBody | ErrorBody | ErrorBody | ErrorBody, TContext = unknown>(options?: {
  mutation?: UseMutationOptions<Awaited<ReturnType<typeof patchBudgetsId>>, TError, { id: number; data: UpdateBudgetInput }, TContext>;
  request?: SecondParameter<typeof customFetch>;
}): UseMutationOptions<Awaited<ReturnType<typeof patchBudgetsId>>, TError, { id: number; data: UpdateBudgetInput }, TContext> => {
  const mutationKey = ["patchBudgetsId"];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && "mutationKey" in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<Awaited<ReturnType<typeof patchBudgetsId>>, { id: number; data: UpdateBudgetInput }> = (props) => {
    const { id, data } = props ?? {};

    return patchBudgetsId(id, data, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type PatchBudgetsIdMutationResult = NonNullable<Awaited<ReturnType<typeof patchBudgetsId>>>;
export type PatchBudgetsIdMutationBody = UpdateBudgetInput;
export type PatchBudgetsIdMutationError = ErrorBody | ErrorBody | ErrorBody | ErrorBody;

/**
 * @summary Update Budget
 */
export const usePatchBudgetsId = <TError = ErrorBody | ErrorBody | ErrorBody | ErrorBody, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<Awaited<ReturnType<typeof patchBudgetsId>>, TError, { id: number; data: UpdateBudgetInput }, TContext>;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient,
): UseMutationResult<Awaited<ReturnType<typeof patchBudgetsId>>, TError, { id: number; data: UpdateBudgetInput }, TContext> => {
  const mutationOptions = getPatchBudgetsIdMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};
/**
 * ‰∫àÁÆó„ÇíÂâäÈô§
 * @summary Delete Budget
 */
export type deleteBudgetsIdResponse204 = {
  data: void;
  status: 204;
};

export type deleteBudgetsIdResponse404 = {
  data: ErrorBody;
  status: 404;
};

export type deleteBudgetsIdResponse500 = {
  data: ErrorBody;
  status: 500;
};

export type deleteBudgetsIdResponseSuccess = deleteBudgetsIdResponse204 & {
  headers: Headers;
};
export type deleteBudgetsIdResponseError = (deleteBudgetsIdResponse404 | deleteBudgetsIdResponse500) & {
  headers: Headers;
};

export type deleteBudgetsIdResponse = deleteBudgetsIdResponseSuccess | deleteBudgetsIdResponseError;

export const getDeleteBudgetsIdUrl = (id: number) => {
  return `/budgets/${id}`;
};

export const deleteBudgetsId = async (id: number, options?: RequestInit): Promise<deleteBudgetsIdResponse> => {
  return customFetch<deleteBudgetsIdResponse>(getDeleteBudgetsIdUrl(id), {
    ...options,
    method: "DELETE",
  });
};

export const getDeleteBudgetsIdMutationOptions = <TError = ErrorBody | ErrorBody, TContext = unknown>(options?: {
  mutation?: UseMutationOptions<Awaited<ReturnType<typeof deleteBudgetsId>>, TError, { id: number }, TContext>;
  request?: SecondParameter<typeof customFetch>;
}): UseMutationOptions<Awaited<ReturnType<typeof deleteBudgetsId>>, TError, { id: number }, TContext> => {
  const mutationKey = ["deleteBudgetsId"];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && "mutationKey" in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<Awaited<ReturnType<typeof deleteBudgetsId>>, { id: number }> = (props) => {
    const { id } = props ?? {};

    return deleteBudgetsId(id, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type DeleteBudgetsIdMutationResult = NonNullable<Awaited<ReturnType<typeof deleteBudgetsId>>>;

export type DeleteBudgetsIdMutationError = ErrorBody | ErrorBody;

/**
 * @summary Delete Budget
 */
export const useDeleteBudgetsId = <TError = ErrorBody | ErrorBody, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<Awaited<ReturnType<typeof deleteBudgetsId>>, TError, { id: number }, TContext>;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient,
): UseMutationResult<Awaited<ReturnType<typeof deleteBudgetsId>>, TError, { id: number }, TContext> => {
  const mutationOptions = getDeleteBudgetsIdMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};
