/**
 * Generated by orval v7.13.2 üç∫
 * Do not edit manually.
 * Budget Calendar Service
 * Budget Calendar API
 * OpenAPI spec version: 1.0
 */
import { useMutation, useQuery } from "@tanstack/react-query";
import type {
  DataTag,
  DefinedInitialDataOptions,
  DefinedUseQueryResult,
  MutationFunction,
  QueryClient,
  QueryFunction,
  QueryKey,
  UndefinedInitialDataOptions,
  UseMutationOptions,
  UseMutationResult,
  UseQueryOptions,
  UseQueryResult,
} from "@tanstack/react-query";

import type {
  CreateCategoryInput,
  CreateCategoryResponse,
  ErrorBody,
  FetchCategoryListsResponse,
  FetchCategoryResponse,
  UpdateCategoryInput,
  UpdateCategoryResponse,
} from ".././model";

import { customFetch } from "../../shared/lib/fetch";

type SecondParameter<T extends (...args: never) => unknown> = Parameters<T>[1];

/**
 * „É¶„Éº„Ç∂„Éº„Å´Á¥ê„Å•„Åè„Ç´„ÉÜ„Ç¥„É™‰∏ÄË¶ß„ÇíÂèñÂæó
 * @summary Get Categories
 */
export const getGetCategoriesUrl = () => {
  return `/categories`;
};

export const getCategories = async (options?: RequestInit): Promise<FetchCategoryListsResponse> => {
  return customFetch<FetchCategoryListsResponse>(getGetCategoriesUrl(), {
    ...options,
    method: "GET",
  });
};

export const getGetCategoriesQueryKey = () => {
  return [`/categories`] as const;
};

export const getGetCategoriesQueryOptions = <TData = Awaited<ReturnType<typeof getCategories>>, TError = ErrorBody>(options?: {
  query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getCategories>>, TError, TData>>;
  request?: SecondParameter<typeof customFetch>;
}) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetCategoriesQueryKey();

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getCategories>>> = ({ signal }) => getCategories({ signal, ...requestOptions });

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<Awaited<ReturnType<typeof getCategories>>, TError, TData> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };
};

export type GetCategoriesQueryResult = NonNullable<Awaited<ReturnType<typeof getCategories>>>;
export type GetCategoriesQueryError = ErrorBody;

export function useGetCategories<TData = Awaited<ReturnType<typeof getCategories>>, TError = ErrorBody>(
  options: {
    query: Partial<UseQueryOptions<Awaited<ReturnType<typeof getCategories>>, TError, TData>> &
      Pick<DefinedInitialDataOptions<Awaited<ReturnType<typeof getCategories>>, TError, Awaited<ReturnType<typeof getCategories>>>, "initialData">;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetCategories<TData = Awaited<ReturnType<typeof getCategories>>, TError = ErrorBody>(
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getCategories>>, TError, TData>> &
      Pick<UndefinedInitialDataOptions<Awaited<ReturnType<typeof getCategories>>, TError, Awaited<ReturnType<typeof getCategories>>>, "initialData">;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetCategories<TData = Awaited<ReturnType<typeof getCategories>>, TError = ErrorBody>(
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getCategories>>, TError, TData>>;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
/**
 * @summary Get Categories
 */

export function useGetCategories<TData = Awaited<ReturnType<typeof getCategories>>, TError = ErrorBody>(
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getCategories>>, TError, TData>>;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getGetCategoriesQueryOptions(options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Êñ∞„Åó„ÅÑ„Ç´„ÉÜ„Ç¥„É™„Çí‰ΩúÊàê
 * @summary Create Category
 */
export const getPostCategoriesUrl = () => {
  return `/categories`;
};

export const postCategories = async (createCategoryInput: CreateCategoryInput, options?: RequestInit): Promise<CreateCategoryResponse> => {
  return customFetch<CreateCategoryResponse>(getPostCategoriesUrl(), {
    ...options,
    method: "POST",
    headers: { "Content-Type": "application/json", ...options?.headers },
    body: JSON.stringify(createCategoryInput),
  });
};

export const getPostCategoriesMutationOptions = <TError = ErrorBody | ErrorBody, TContext = unknown>(options?: {
  mutation?: UseMutationOptions<Awaited<ReturnType<typeof postCategories>>, TError, { data: CreateCategoryInput }, TContext>;
  request?: SecondParameter<typeof customFetch>;
}): UseMutationOptions<Awaited<ReturnType<typeof postCategories>>, TError, { data: CreateCategoryInput }, TContext> => {
  const mutationKey = ["postCategories"];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && "mutationKey" in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<Awaited<ReturnType<typeof postCategories>>, { data: CreateCategoryInput }> = (props) => {
    const { data } = props ?? {};

    return postCategories(data, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type PostCategoriesMutationResult = NonNullable<Awaited<ReturnType<typeof postCategories>>>;
export type PostCategoriesMutationBody = CreateCategoryInput;
export type PostCategoriesMutationError = ErrorBody | ErrorBody;

/**
 * @summary Create Category
 */
export const usePostCategories = <TError = ErrorBody | ErrorBody, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<Awaited<ReturnType<typeof postCategories>>, TError, { data: CreateCategoryInput }, TContext>;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient,
): UseMutationResult<Awaited<ReturnType<typeof postCategories>>, TError, { data: CreateCategoryInput }, TContext> => {
  const mutationOptions = getPostCategoriesMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};
/**
 * „Ç´„ÉÜ„Ç¥„É™„ÅÆË©≥Á¥∞„ÇíÂèñÂæó
 * @summary Get Category
 */
export const getGetCategoriesIdUrl = (id: number) => {
  return `/categories/${id}`;
};

export const getCategoriesId = async (id: number, options?: RequestInit): Promise<FetchCategoryResponse> => {
  return customFetch<FetchCategoryResponse>(getGetCategoriesIdUrl(id), {
    ...options,
    method: "GET",
  });
};

export const getGetCategoriesIdQueryKey = (id?: number) => {
  return [`/categories/${id}`] as const;
};

export const getGetCategoriesIdQueryOptions = <TData = Awaited<ReturnType<typeof getCategoriesId>>, TError = ErrorBody | ErrorBody | ErrorBody>(
  id: number,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getCategoriesId>>, TError, TData>>;
    request?: SecondParameter<typeof customFetch>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetCategoriesIdQueryKey(id);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getCategoriesId>>> = ({ signal }) => getCategoriesId(id, { signal, ...requestOptions });

  return { queryKey, queryFn, enabled: !!id, ...queryOptions } as UseQueryOptions<Awaited<ReturnType<typeof getCategoriesId>>, TError, TData> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };
};

export type GetCategoriesIdQueryResult = NonNullable<Awaited<ReturnType<typeof getCategoriesId>>>;
export type GetCategoriesIdQueryError = ErrorBody | ErrorBody | ErrorBody;

export function useGetCategoriesId<TData = Awaited<ReturnType<typeof getCategoriesId>>, TError = ErrorBody | ErrorBody | ErrorBody>(
  id: number,
  options: {
    query: Partial<UseQueryOptions<Awaited<ReturnType<typeof getCategoriesId>>, TError, TData>> &
      Pick<
        DefinedInitialDataOptions<Awaited<ReturnType<typeof getCategoriesId>>, TError, Awaited<ReturnType<typeof getCategoriesId>>>,
        "initialData"
      >;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetCategoriesId<TData = Awaited<ReturnType<typeof getCategoriesId>>, TError = ErrorBody | ErrorBody | ErrorBody>(
  id: number,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getCategoriesId>>, TError, TData>> &
      Pick<
        UndefinedInitialDataOptions<Awaited<ReturnType<typeof getCategoriesId>>, TError, Awaited<ReturnType<typeof getCategoriesId>>>,
        "initialData"
      >;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetCategoriesId<TData = Awaited<ReturnType<typeof getCategoriesId>>, TError = ErrorBody | ErrorBody | ErrorBody>(
  id: number,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getCategoriesId>>, TError, TData>>;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
/**
 * @summary Get Category
 */

export function useGetCategoriesId<TData = Awaited<ReturnType<typeof getCategoriesId>>, TError = ErrorBody | ErrorBody | ErrorBody>(
  id: number,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getCategoriesId>>, TError, TData>>;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getGetCategoriesIdQueryOptions(id, options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * „Ç´„ÉÜ„Ç¥„É™„ÇíÊõ¥Êñ∞ÔºàÈÉ®ÂàÜÊõ¥Êñ∞Ôºâ
 * @summary Update Category
 */
export const getPatchCategoriesIdUrl = (id: number) => {
  return `/categories/${id}`;
};

export const patchCategoriesId = async (
  id: number,
  updateCategoryInput: UpdateCategoryInput,
  options?: RequestInit,
): Promise<UpdateCategoryResponse> => {
  return customFetch<UpdateCategoryResponse>(getPatchCategoriesIdUrl(id), {
    ...options,
    method: "PATCH",
    headers: { "Content-Type": "application/json", ...options?.headers },
    body: JSON.stringify(updateCategoryInput),
  });
};

export const getPatchCategoriesIdMutationOptions = <TError = ErrorBody | ErrorBody | ErrorBody, TContext = unknown>(options?: {
  mutation?: UseMutationOptions<Awaited<ReturnType<typeof patchCategoriesId>>, TError, { id: number; data: UpdateCategoryInput }, TContext>;
  request?: SecondParameter<typeof customFetch>;
}): UseMutationOptions<Awaited<ReturnType<typeof patchCategoriesId>>, TError, { id: number; data: UpdateCategoryInput }, TContext> => {
  const mutationKey = ["patchCategoriesId"];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && "mutationKey" in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<Awaited<ReturnType<typeof patchCategoriesId>>, { id: number; data: UpdateCategoryInput }> = (props) => {
    const { id, data } = props ?? {};

    return patchCategoriesId(id, data, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type PatchCategoriesIdMutationResult = NonNullable<Awaited<ReturnType<typeof patchCategoriesId>>>;
export type PatchCategoriesIdMutationBody = UpdateCategoryInput;
export type PatchCategoriesIdMutationError = ErrorBody | ErrorBody | ErrorBody;

/**
 * @summary Update Category
 */
export const usePatchCategoriesId = <TError = ErrorBody | ErrorBody | ErrorBody, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<Awaited<ReturnType<typeof patchCategoriesId>>, TError, { id: number; data: UpdateCategoryInput }, TContext>;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient,
): UseMutationResult<Awaited<ReturnType<typeof patchCategoriesId>>, TError, { id: number; data: UpdateCategoryInput }, TContext> => {
  const mutationOptions = getPatchCategoriesIdMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};
/**
 * „Ç´„ÉÜ„Ç¥„É™„ÇíÂâäÈô§
 * @summary Delete Category
 */
export const getDeleteCategoriesIdUrl = (id: number) => {
  return `/categories/${id}`;
};

export const deleteCategoriesId = async (id: number, options?: RequestInit): Promise<void> => {
  return customFetch<void>(getDeleteCategoriesIdUrl(id), {
    ...options,
    method: "DELETE",
  });
};

export const getDeleteCategoriesIdMutationOptions = <TError = ErrorBody | ErrorBody | ErrorBody, TContext = unknown>(options?: {
  mutation?: UseMutationOptions<Awaited<ReturnType<typeof deleteCategoriesId>>, TError, { id: number }, TContext>;
  request?: SecondParameter<typeof customFetch>;
}): UseMutationOptions<Awaited<ReturnType<typeof deleteCategoriesId>>, TError, { id: number }, TContext> => {
  const mutationKey = ["deleteCategoriesId"];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && "mutationKey" in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<Awaited<ReturnType<typeof deleteCategoriesId>>, { id: number }> = (props) => {
    const { id } = props ?? {};

    return deleteCategoriesId(id, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type DeleteCategoriesIdMutationResult = NonNullable<Awaited<ReturnType<typeof deleteCategoriesId>>>;

export type DeleteCategoriesIdMutationError = ErrorBody | ErrorBody | ErrorBody;

/**
 * @summary Delete Category
 */
export const useDeleteCategoriesId = <TError = ErrorBody | ErrorBody | ErrorBody, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<Awaited<ReturnType<typeof deleteCategoriesId>>, TError, { id: number }, TContext>;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient,
): UseMutationResult<Awaited<ReturnType<typeof deleteCategoriesId>>, TError, { id: number }, TContext> => {
  const mutationOptions = getDeleteCategoriesIdMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};
